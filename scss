Как сделать ссылку на родителя селектора ?

Что такое шаблонные селекторы ?

Какие коментарии сохранятся а какие не попадут в гит хаб или в скомпилированный  файл ?

Как обьявить переменную с чем либо ? 

Что делает import &

Что делает _vars.scss  что означает нижнее подчеркивание ?

Как работает директива @media ?


Как обьявить миксин  ?

Что делают аргументы миксина ?













































































Ответы 
Как сделать ссылку на родителя селектора ?

Символ & будет заменен на родительский селектор, каким он компилируется в CSS. Это означает, что если у вас есть глубоко вложенное правило, родительский селектор будет полностью вычислен до символа & и подставится вместо него. Например:
Scss
a {
  font-weight: bold;
  text-decoration: none;

  &:hover {
    text-decoration: underline;
  }

  body.firefox & {    <-------------------
    font-weight: normal;
  }
}


CSS
a {
  font-weight: bold;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

body.firefox a { <-----------
  font-weight: normal;
}

#main {
  color: black;

  a {
    font-weight: bold;

    &:hover { <-------
      color: red;
    }
  }
}

#main {
  color: black;
}

#main a {
  font-weight: bold;
}

#main a:hover {
  color: red; <------
}


Что такое шаблонные селекторы ?
Sass поддерживает специальный тип селекторов под названием шаблонные селекторы. Они похожи на селекторы классов и идентификаторов, только вместо # или . указывается %. Они предназначены для использования с директивой @extend

Сами по себе, без использования @extend, наборы правил, которые используют шаблонные селекторы, не окажут влияния на CSS. Например:

Можно прописывать много свойств и потом передавать через @extend
Scss
%for-grids {
    min-height: 1px;
    position: relative;
    padding-left: 10px;
    padding-right: 10px;
    margin-bottom: 20px;
}


.sgrid-N {
    @extend %for-grids;
}


CSS
.sgrid-N {
  min-height: 1px;
  position: relative;
  padding-left: 10px;
  padding-right: 10px;
  margin-bottom: 20px;
}


Какие коментарии сохранятся а какие не попадут в гит хаб или в скомпилированный  файл ?

/* Это многострочный комментарий.
 * Так как этот тип комментирования
 * поддерживается в CSS, то он
 * попадет в скомпилированный CSS-файл. */
body { color: black; }

// Это однострочный комментарий.
// CSS не поддерживает данный вариант комментирования.
// Поэтому данного комментария не будет в CSS-файле.
a { color: green; }


Если первым символом многострочного комментария является знак !, то комментарий всегда будет оставаться в результирующем CSS, даже в режиме сжатия. Это полезно, например, для добавления уведомления об авторских правах на ваш CSS.


Как обьявить переменную с чем либо ? 
Самое простое, что поддерживает SassScript - это использование переменных. Переменные начинаются со знака доллара $ и задаются как свойства CSS:

$width: 5em;
#main {
  width: $width;
}

Переменные доступны только в пределах того уровня вложенности селекторов, на котором они определены. Если они определяются вне каких-либо вложенных селекторов, они доступны глобально. Если вы хотите, чтобы объявленная на каком-либо уровне вложенности переменная также была доступна глобально, вы можете определить её со специальной меткой !global. Например:


Что делает import &
Sass расширяет CSS правило 1 @import, позволяя импортировать scss и sass файлы. Все импортированные scss и sass файлы могут быть объединены в одном результирующем css файле. Кроме того, любые переменные или миксины, объявленные в импортированном файле, могут использоваться в главном файле.

@import "foo";


Что делает _vars.scss  что означает нижнее подчеркивание ?
их называют фрагменты 
Если у Вас есть scss или sass файл, который вы хотите импортировать, но не хотите его компилировать напрямую в CSS-файл, то добавьте нижнее подчеркивание в начало имени файла. Это сообщит Sass о том, что не нужно компилировать этот файл напрямую в CSS. Когда импортируете такой файл, то нижнее подчеркивание можно не указывать.

Обратите внимание на то, что невозможно импортировать фрагмент и полноценный файл Sass c одинаковым именем, а также и находящимися в одной папке, одновременно. Например, файл colors.scss не может сосуществовать с фрагментом _colors.scss.


Как работает директива @media ?
Директива @media работает так же, как и стандартное правило CSS, только с дополнительными возможностями: директива может вкладываться в правила CSS. Если директива вложена в css-правило, то при компиляции она будет поднята наверх таблицы стилей, а все селекторы в которых была директива переместятся внутрь @media. Такой метод позволяет легко добавлять правила в @media без повторения селекторов или нарушения потока таблицы стилей. Например:
Scss
.sidebar {
  width: 300px;

  @media screen and (orientation: landscape) {
    width: 500px;
  }
}

Css 
.sidebar {
  width: 300px; 
}

@media screen and (orientation: landscape) {
  .sidebar {
    width: 500px; 
  } 
}

@media запросы могут вкладываться друг в друга. После компиляции эти @media будут объединены оператором and.

Scss
@media screen {
  .sidebar {
    @media (orientation: landscape) {
      width: 500px;
    }
  }
}

Css 
@media screen and (orientation: landscape) {
  .sidebar {
    width: 500px; 
  } 
}

Ну и, наконец, @media запросы могут содержать в себе все возможности SassScript (включая переменные, функции и операторы) в именах компонентов и различных значений. Например:

Scss 
$media: screen;
$feature: -webkit-min-device-pixel-ratio;
$value: 1.5;

@media #{$media} and ($feature: $value) {
  .sidebar {
    width: 500px;
  }
}

Css 
@media screen and (-webkit-min-device-pixel-ratio: 1.5) {
  .sidebar {
    width: 500px; 
  } 
}


Как обьявить миксин  ?

@mixin large-text {
  font: {
    family: Arial;
    size: 20px;
    weight: bold;
  }
  color: #ff0000;
}


Использование миксина 
Scss
.page-title {
  @include large-text;
  padding: 4px;
  margin-top: 10px;
}

Css
.page-title {
  font-family: Arial;
  font-size: 20px;
  font-weight: bold;
  color: #ff0000;
  padding: 4px;
  margin-top: 10px; 
}


Что делают аргументы миксина ?
Миксины могут принимать значения SassScript как аргументы, которые передаются при подключении миксина и становятся доступными как переменные внутри него.

При определении миксина, аргументы пишутся как имена переменных, разделённые запятыми внутри круглых скобок сразу после имени. Затем, при подключении миксина, значения могут быть переданы аналогичным образом. Например:

Scss
@mixin sexy-border($color, $width) {
  border: {
    color: $color;
    width: $width;
    style: dashed;
  }
}

p { 
  @include sexy-border(blue, 1in);
}

Css 
p {
  border-color: blue;
  border-width: 1in;
  border-style: dashed; 
}

Scss 
@mixin sexy-border($color, $width: 1in) {
  border: {
    color: $color;
    width: $width;
    style: dashed;
  }
}
p { 
  @include sexy-border(blue); 
}
h1 { 
  @include sexy-border(blue, 2in); 
}

Css
p {
  border-color: blue;
  border-width: 1in;
  border-style: dashed; 
}

h1 {
  border-color: blue;
  border-width: 2in;
  border-style: dashed; 
}


Именованные аргументы
p {
  @include sexy-border($color: blue); 
}

h1 {
  @include sexy-border($color: blue, $width: 2in); 
}

Данный способ записи делает код менее кратким, но более читабельным. Также он позволяет функциям представлять более гибкие интерфейсы: большое количество параметров у функции не усложняет её вызов.

Именованные аргументы можно передавать в любом порядке, аргументы, имеющие значения по-умолчанию, могут быть пропущены. Так как именованные аргументы - это имена переменных, символы подчёркивания и дефисы могут быть использованы как взаимозаменяемые.

Переменные в аргументах
Scss
@mixin box-shadow($shadows...) {
  -moz-box-shadow: $shadows;
  -webkit-box-shadow: $shadows;
  box-shadow: $shadows;
}

.shadows {
  @include box-shadow(0px 4px 5px #666, 2px 6px 10px #999);
}

Css 
.shadows {
  -moz-box-shadow: 0px 4px 5px #666, 2px 6px 10px #999;
  -webkit-box-shadow: 0px 4px 5px #666, 2px 6px 10px #999;
  box-shadow: 0px 4px 5px #666, 2px 6px 10px #999;
}


Область видимости переменных и блоков контента
Scss
$color: white;
@mixin colors($color: blue) {
  background-color: $color;
  @content;
  border-color: $color;
}

.colors {
  @include colors {
    color: $color;
  }
}

Css 
.colors {
  background-color: blue;
  color: white;
  border-color: blue;
}









