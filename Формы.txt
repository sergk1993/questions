Проверка знаний MDN 
https://developer.mozilla.org/en-US/docs/Learn/Forms/Test_your_skills:_Form_validation

Что прописывается в form ?

какие существуют type у button ?

В чем разница между button и input с type="submit" ?

Что нужно прописать в форме для отправке данных на сервер ?

Что нельзя вставлять в форму ? 


Для чего эти элементы <fieldset> и <legend> ?

Какие есть виджеты форм ? 

Сколько  атрибутов валидации у элементов формы существует и какие, и что они делают ?


Для чего  атрибут pattern ?

Что делает min max ? 

что нужно прописать в форме что бы к ней обратиться в js ?

как изменить name ? 

почему не нужно использовать textarea.innerHTML 

почему может выходить ошибка когда выводишь форму ?

какие свойства есть у select и option ? 

что такое new Option ? 

в чем разница События focus/blur ?


Какие атрибуты позволяют делать валидацию ? 

Что это focusin и focusout что с ними не сработает что сработало с focus blur ? 


Что делает событие Событие: change ?

Что делает событие Событие: input ? 

Что делает События: cut, copy, paste ?

Что делает метод form.submit() ?


Какие два типа валидации на стороне клиента, с которыми вы можете столкнуться в Интернете ?

какие существуют ошибки, которые не позволяют отправлять форму ?

Что делает атрибут novalidate ?

Что такое aria-live ?

































































Ответы 
Что прописывается в form ?
action=""  method=""
Атрибут action определяет адрес, куда должны быть посланы данные после отправки формы.
Атрибут method указывает, какой HTTP-метод будет использован при передаче данных (это может быть "get" или "post").

HTML-формы могут передаваться несколькими различными способами, наиболее распространёнными из которых являются метод GET и метод POST.
Метод GET - это метод, используемый браузером, который говорит серверу, что нужно отправить назад данный ресурс: «Эй, сервер, я хочу получить этот ресурс». В этом случае браузер отправляет пустое тело. Поскольку тело пустое, если форма отправляется с использованием данного метода, данные, отправляемые на сервер, добавляются к URL-адресу.
Метод POST немного отличается. Браузер использует этот метод для связи с сервером при запросе ответа с учётом данных, представленные в теле HTTP-запроса: «Эй, сервер, взгляни на эти данные и отправь мне соответствующий результат». Если форма отправляется с использованием этого метода, данные добавляются в тело HTTP-запроса.



какие существуют type у button ?
HTML-элемент <button> также принимает атрибут type, который может быть равен одному из трёх значений: submit, reset или button.

Клик по кнопке submit (значение по умолчанию) отправляет данные из формы на страницу, определённую в атрибуте action элемента <form>.
Клик по кнопке reset сбрасывает значения всех элементов управления формы к их начальному значению. С точки зрения UX, это считается плохой практикой.
Клик по кнопке button не делает ничего! Звучит странно, но на самом деле это очень удобно использовать для создания собственных кнопок — вы можете определить их поведение через JavaScript.


В чем разница между button и input с type="submit" ?
HTML-элемент <input> с соответствующим атрибутом type , чтобы создать кнопку:  <input type="submit">. Главным преимуществом HTML-элемента <button> в сравнении с элементом <input> заключается в том, что <input> может принимать в себя только простой текст, в то время как <button> позволяет использовать весь HTML для создания более стилизованного текста внутри кнопки.

Внутри элемента кнопки вы можете разместить контент, текст или изображение. Вот в чем разница между этим элементом и кнопкой, созданной с помощью элемента input. Всегда указывайте тип атрибута для кнопки. Тип по умолчанию для Internet Explorer является "button", а в других браузерах (и в спецификации W3C) это "submit"


Что нужно прописать в форме для отправке данных на сервер ?
HTML-элемент <form> определяет куда и каким способом отправить данные благодаря атрибутам action и method.

Мы определяем имя name для каждого виджета формы. Указание имён важно как для браузера, так и для сервера: браузер узнаёт, какие имена дать каждой части данных, а сервер может получить эти данные, обратясь к ним по заданному имени. Данные форму отправляются на сервер в виде пары имя/значение.

Чтобы переименовать данные, вам необходимо использовать атрибут name на каждом виджете формы, который будет собирать определённую часть информации


    <form action="" method="post">
        <ul>
            <li>
                <label for="name">Name:</label>
                <input type="text" id="name" name="user_name" >
            </li>
            <li>
                <label for="mail">E-mail:</label>
                <input type="email" id="mail" name="user_mail">
            </li>
            <li>
                <label for="msg">Message:</label>
                <textarea id="msg" name="user_message"></textarea>
            </li>
            <li class="button">
                <button type="submit">Send your message</button>
            </li>
        </ul>
    </form>


В нашем примере форма отправит три куска данных с именами "user_name", "user_email" и "user_message". Эти данные будут отправлены на URL "/my-handling-form-page" через метод HTTP POST.

На стороне сервера скрипт, расположенный на URL "/my-handling-form-page" получит данные в виде списка из 3 элементов вида ключ/значение, содержащихся в HTTP-запросе

Что нельзя вставлять в форму ? 
Строго запрещается размещать форму внутри другой формы. Такое размещение может привести к непредсказуемому поведению форм, в зависимости от браузера. 


Для чего эти элементы <fieldset> и <legend> ?
<fieldset></fieldset> - используется для группировки нескольких элементов управления без веб-форм, используется в форме 
Вы можете установить заголовок <fieldset>, добавив элемент <legend> сразу после открывающего тега <fieldset>. Текст элемента <legend> формально описывает назначение содержимого <fieldset>.

Различные вспомогательные технологии будут использовать <legend> как часть метки label всех элементов внутри <fieldset>. Например, такие экранные дикторы как Jaws или NVDA произносят заголовок формы <legend> перед произношением названия меток элементов.

есть форма 
    <form>
        <fieldset>
          <legend>Fruit juice size</legend>
          <p>
            <input type="radio" name="size" id="size_1" value="small">
            <label for="size_1">Small</label>
          </p>
          <p>
            <input type="radio" name="size" id="size_2" value="medium">
            <label for="size_2">Medium</label>
          </p>
          <p>
            <input type="radio" name="size" id="size_3" value="large">
            <label for="size_3">Large</label>
          </p>
        </fieldset>
    </form>

Читая эту форму, экранный диктор произнесёт "Fruit juice size small" для первого элемента, "Fruit juice size medium" - для второго, "Fruit juice size large" - для третьего.

Из-за своего влияния на вспомогательные технологии элемент <fieldset> является одним из ключевых элементов для построения доступных форм; однако вы не должны им злоупотреблять. Если возможно, старайтесь проверять, как экранный диктор интерпретирует вашу форму. 

В предыдущей статье мы увидели, что элемент <label> принято использовать для указания текстов-подсказок (лейблов) в HTML-формах. Это самый важный элемент для построения доступных форм — при правильной реализации скринридеры будут озвучивать текст-подсказку вместе со связанными элементами

<label for="name">Name:</label> <input type="text" id="name" name="user_name">
При правильно связанном элементе <label> с элементом <input> через атрибуты for и id соответственно (атрибут for ссылается на атрибут id соответствующего виджета формы), скринридер прочтёт вслух что-то наподобие "Name, edit text"


нужно читать дальше 
Basic native form controls
https://developer.mozilla.org/ru/docs/Learn/Forms/Basic_native_form_controls


Какие есть виджеты форм ? 
autofocus
Этот атрибут логического типа позволяет вам определить, должен ли элемент автоматически попадать в фокус при загрузке страницы, пока пользователь не изменит это, например, печатая в другом виджете. Этот атрибут может явно определяться только для одного элемента в документе, ассоциированного с формой.

disabled
Этот атрибут логического типа определяет, может ли пользователь взаимодействовать с элементом. Если этот атрибут не определён, то элемент наследует его значение от элемента-родителя. Если атрибут не определён, то по умолчанию пользователь может взаимодействовать с элементом.

form
Элемент формы, с которым ассоциирован виджет. Значением данного атрибута должен быть атрибут id элемента <form>  в том же документе. Теоретически, это позволяет вам помещать определение виджета за рамками элемента <form>. На практике, однако, не существует браузеров, поддерживающих данную функцию.

name
Название элемента; передаётся вместе с данными формы.

value 
Начальное значение элемента. 

Текстовые поля <input>  являются самыми базовыми виджетами форм.

Сколько  атрибутов валидации у элементов формы существует и какие, и что они делают ?
required: Определяет, что для отправки формы данное поле предварительно должно быть заполнено.
minlength и maxlength: Задаёт минимальную и максимальную длину текстовых данных (строк)
min и max: Задаёт минимальное и максимальное значение для поля, расчитанного на числовой тип данных
type: Определяет тип данных, на который рассчитано поле: число, email-адрес или какой-то другой предустановленный тип
pattern: С помощью регулярного выражения, определяет шаблон, которому должны соответствовать вводимые данные.


можно обращатся к  css файлам 
input:invalid {
  border: 2px dashed red;
}

input:invalid:required {
  background-image: linear-gradient(to right, pink, lightgreen);
}

input:valid {
  border: 2px solid black;
} 

Для чего  атрибут pattern ?
Примечание: Элемент <textarea> (en-US) не поддерживает атрибут pattern.
Ещё одной полезной функцией валидации является атрибут pattern, который в виде значения принимает Регулярное выражение.
Регулярное выражение (regex) — это шаблон, который может быть использован для сопоставления набора символов в текстовой строке, поэтому они идеально подходят для валидации формы и используются для множества других целей в JavaScript.
pattern="[Bb]anana|[Cc]herry"

с помощью шаблона "Bb", вложенного в квадратные скобки, мы сделали поддержку написания слова как с большой, так и с маленькой буквы

<form>
  <label for="choose">Would you prefer a banana or a cherry?</label>
  <input id="choose" name="i_like" required pattern="[Bb]anana|[Cc]herry">
  <button>Submit</button>
</form>

когда введешь banana то форма сработает 

Что делает min max ? 
<form>
  <div>
    <label for="choose">Would you prefer a banana or a cherry?</label>
    <input type="text" id="choose" name="i_like" required minlength="6" maxlength="6">
  </div>
  <div>
    <label for="number">How many would you like?</label>
    <input type="number" id="number" name="amount" value="1" min="1" max="10">
  </div>
  <div>
    <button>Submit</button>
  </div>
</form>

Здесь мы в полю с типом text атрибутам minlength и maxlength, задали одинаковое значение 6, что соответствует количеству символов в словах banana и cherry.
В поле с типом number атрибуту min мы задали значение 1, а атрибуту max значение 10. При вводе чисел за пределами данного диапазона, поле будет становиться не валидным; с помощью стрелок увеличения/уменьшения пользователи не смогут выйти за границы диапазона. Текущее поле не является обязательным для заполнения, поэтому даже после очистки будет оставаться валидным.

Ниже представлен полный пример, демонстрирующий использование встроенного функционала валидации. Сначала немного HTML:

<form>
  <p>
    <fieldset>
      <legend>Do you have a driver's license?<abbr title="This field is mandatory" aria-label="required">*</abbr></legend>
      <!-- Так как в группе радио-кнопок, имеющих одинаковое имя, выбранной может быть
          только одна, то и атрибут "required" достаточно задать хотя бы одной кнопке,
          чтобы сделать всю группу обязательной для заполнения -->
      <input type="radio" required name="driver" id="r1" value="yes"><label for="r1">Yes</label>
      <input type="radio" required name="driver" id="r2" value="no"><label for="r2">No</label>
    </fieldset>
  </p>
  <p>
    <label for="n1">How old are you?</label>
    <!-- Атрибут "pattern" может выступать фолбэком для браузеров, которые
        не поддерживают поля ввода c числовым типом данных. Те браузеры,
        которые такие поля поддерживают, будут просто игнорировать его.
        Как раз, ниже атрибут "pattern" выполняет роль фолбека.
     -->
    <input type="number" min="12" max="120" step="1" id="n1" name="age"
           pattern="\d+">
  </p>
  <p>
    <label for="t1">What's your favorite fruit?<abbr title="This field is mandatory" aria-label="required">*</abbr></label>
    <input type="text" id="t1" name="fruit" list="l1" required
           pattern="[Bb]anana|[Cc]herry|[Aa]pple|[Ss]trawberry|[Ll]emon|[Oo]range">
    <datalist id="l1">
      <option>Banana</option>
      <option>Cherry</option>
      <option>Apple</option>
      <option>Strawberry</option>
      <option>Lemon</option>
      <option>Orange</option>
    </datalist>
  </p>
  <p>
    <label for="t2">What's your e-mail address?</label>
    <input type="email" id="t2" name="email">
  </p>
  <p>
    <label for="t3">Leave a short message</label>
    <textarea id="t3" name="msg" maxlength="140" rows="5"></textarea>
  </p>
  <p>
    <button>Submit</button>
  </p>
</form>


что нужно прописать в форме что бы к ней обратиться в js ?
нужно прописать в форме имя и по нему оброщаться 
<form action="" method="post" name="my"> </form>
document.forms.my


если будет такая форма 
<form>
  <input type="radio" name="age" value="10">
  <input type="radio" name="age" value="20">
</form>
вывод будет таким 
form.elements.age
Все элементы управления формы, как бы глубоко они не находились в форме, доступны в коллекции form.elements.


как изменить name ? 
form.login.name = "username";
<form id="form">
  <input name="login">
</form>

<script>
  alert(form.elements.login == form.login); // true, ведь это одинаковые <input>

  form.login.name = "username"; // изменяем свойство name у элемента input

  // form.elements обновили свои имена:
  alert(form.elements.login); // undefined
  alert(form.elements.username); // input

  // а в form мы можем использовать оба имени: новое и старое
  alert(form.username == form.login); // true
</script>


почему не нужно использовать textarea.innerHTML ?
Используйте textarea.value вместо textarea.innerHTML
Обратим внимание: хоть элемент <textarea>...</textarea> и хранит своё значение как вложенный HTML, нам не следует использовать textarea.innerHTML для доступа к нему.

Там хранится только тот HTML, который был изначально на странице, а не текущее значение.



почему может выходить ошибка когда выводишь форму ?
потому что у формы нет айдишника 



какие свойства есть у select и option ? 

Элемент <select> имеет 3 важных свойства:
select.options – коллекция из подэлементов <option>,
select.value – значение выбранного в данный момент <option>,
select.selectedIndex – номер выбранного <option>.

Они дают три разных способа установить значение в <select>:

Найти соответствующий элемент <option> и установить в option.selected значение true.
Установить в select.value значение нужного <option>.
Установить в select.selectedIndex номер нужного <option>

Первый способ наиболее понятный, но (2) и (3) являются более удобными при работе.

Вот эти способы на примере:

<select id="select">
  <option value="apple">Яблоко</option>
  <option value="pear">Груша</option>
  <option value="banana">Банан</option>
</select>

<script>
  // все три строки делают одно и то же
  select.options[2].selected = true;
  select.selectedIndex = 2;
  select.value = 'banana';
</script>


что такое new Option ? 
Элемент <option> редко используется сам по себе, но и здесь есть кое-что интересное.

В спецификации есть красивый короткий синтаксис для создания элемента <option>:

option = new Option(text, value, defaultSelected, selected);
Параметры:

text – текст внутри <option>,
value – значение,
defaultSelected – если true, то ставится HTML-атрибут selected,
selected – если true, то элемент <option> будет выбранным.
Тут может быть небольшая путаница с defaultSelected и selected. Всё просто: defaultSelected задаёт HTML-атрибут, его можно получить как option.getAttribute('selected'), а selected – выбрано значение или нет, именно его важно поставить правильно. Впрочем, обычно ставят оба этих значения в true или не ставят вовсе (т.е. false).

let option = new Option("Текст", "value");
// создаст <option value="value">Текст</option>

<select id="genres">
  <option value="rock">Рок</option>
  <option value="blues" selected>Блюз</option>
</select> 

Выведите значение и текст выбранного пункта.
Добавьте пункт: <option value="classic">Классика</option>.
Сделайте его выбранным.

<select id="genres">
  <option value="rock">Рок</option>
  <option value="blues" selected>Блюз</option>
</select>

<script>
  // 1)
  let selectedOption = genres.options[genres.selectedIndex];
  alert( selectedOption.value );
  alert( selectedOption.text );

  // 2)
  let newOption = new Option("Классика", "classic");
  genres.append(newOption);

  // 3)
  newOption.selected = true;
</script>

в чем разница События focus/blur ? 
Событие focus вызывается в момент фокусировки, а blur – когда элемент теряет фокус

если хочешь прикрутить это к импуту 
input.onblur = function() {
  if (!input.value.includes('@')) { // не email
    input.classList.add('invalid');
    error.innerHTML = 'Пожалуйста, введите правильный email.'
  }
};


Какие атрибуты позволяют делать валидацию ? 
Современный HTML позволяет делать валидацию с помощью атрибутов required, pattern



Что это focusin и focusout что с ними не сработает что сработало с focus blur ? 
Заметьте, что эти события должны использоваться с elem.addEventListener, но не с on<event>.

<form id="form">
  <input type="text" name="name" value="Имя">
  <input type="text" name="surname" value="Фамилия">
</form>

<style> .focused { outline: 1px solid red; } </style>

<script>
  form.addEventListener("focusin", () => form.classList.add('focused'));
  form.addEventListener("focusout", () => form.classList.remove('focused'));
</script>


Что делает событие Событие: change ?
Событие change срабатывает по окончании изменения элемента.
Для текстовых <input> это означает, что событие происходит при потере фокуса.

Для других элементов: select, input type=checkbox/radio событие запускается сразу после изменения значения:

<select onchange="alert(this.value)">
  <option value="">Выберите что-нибудь</option>
  <option value="1">Вариант 1</option>
  <option value="2">Вариант 2</option>
  <option value="3">Вариант 3</option>
</select>

при каждом выборе будет выводить в консоль value элемента 

Что делает событие Событие: input ?
Событие input срабатывает каждый раз при изменении значения.

В отличие от событий клавиатуры, оно работает при любых изменениях значений, даже если они не связаны с клавиатурными действиями: вставка с помощью мыши или распознавание речи при диктовке текста.

<input type="text" id="input"> oninput: <span id="result"></span>
<script>
  input.oninput = function() {
    result.innerHTML = input.value;
  };
</script>

при вводе текста он сразу будет выводиться 

С другой стороны, событие input не происходит при вводе с клавиатуры или иных действиях, если при этом не меняется значение в текстовом поле, т.е. нажатия клавиш ⇦, ⇨ и подобных при фокусе на текстовом поле не вызовут это событие.

Что делает События: cut, copy, paste ?
Эти события происходят при вырезании/копировании/вставке данных.
Они относятся к классу ClipboardEvent и обеспечивают доступ к копируемым/вставляемым данным.
Мы также можем использовать event.preventDefault() для предотвращения действия по умолчанию, и в итоге ничего не скопируется/не вставится.

Технически, мы можем скопировать/вставить всё. Например, мы можем скопировать файл из файловой системы и вставить его.
Существует список методов в спецификации для работы с различными типами данных, чтения/записи в буфер обмена.
Но обратите внимание, что буфер обмена работает глобально, на уровне ОС. Большинство браузеров в целях безопасности разрешают доступ на чтение/запись в буфер обмена только в рамках определённых действий пользователя, к примеру, в обработчиках событий onclick.
Также запрещается генерировать «пользовательские» события буфера обмена при помощи dispatchEvent во всех браузерах, кроме Firefox.

Что делает метод form.submit() ?
Метод form.submit() позволяет инициировать отправку формы из JavaScript. Мы можем использовать его для динамического создания и отправки наших собственных форм на сервер.
Первый – нажать кнопку <input type="submit"> или <input type="image">.
Второй – нажать Enter, находясь на каком-нибудь поле.

Чтобы отправить форму на сервер вручную, мы можем вызвать метод form.submit().
При этом событие submit не генерируется. Предполагается, что если программист вызывает метод form.submit(), то он уже выполнил всю соответствующую обработку.
Иногда это используют для генерации формы и отправки её вручную, например так:
let form = document.createElement('form');
form.action = 'https://google.com/search';
form.method = 'GET';

form.innerHTML = '<input name="q" value="test">';

// перед отправкой формы, её нужно вставить в документ
document.body.append(form);

form.submit();

Какие два типа валидации на стороне клиента, с которыми вы можете столкнуться в Интернете ?
Встроенная валидация форм использует функционал валидации
HTML5-валидация
HTML5-валидация обычно не требует большого количества JavaScript-кода и демонстрирует лучшую производительность, но не настолько настраиваема, как валидация с помощью JavaScript



какие существуют ошибки, которые не позволяют отправлять форму ?
Примечание: Существует ошибки, которые не позволяют отправлять форму, в частности badInput, patternMismatch, rangeOverflow или rangeUnderflow, stepMismatch, tooLong или tooShort, typeMismatch, valueMissing, или customError.


Что делает атрибут novalidate ?
Эта простая форма использует атрибут novalidate, который отключает автоматическую валидацию браузером; это позволяет нашему скрипту взять управление валидацией на себя. Однако, это не отменяет поддержку Constraint Validation API или псевдоклассов, таких как :valid или ему подобных. Это значит, что хотя браузер автоматически и не проверяет валидность формы перед отправкой данных, вы можете сделать это самостоятельно и соответствующим образом стилизовать форму.


Что такое aria-live ?
When content changes after initial load, assistive technology (AT) users may not "see" the changes. Some changes are important. Others are not. The aria-live attribute enables developers to inform the user of updates and choose, based on importance and urgency, whether to immediately, proactively, or passively inform AT users of changes to the content.

Мы хотим показывать сообщение об ошибке внутри элемента <span>. Данному элементу задан атрибут aria-live, чтобы гарантировать, что наше кастомное сообщение об ошибке будет доступно всем, включая пользователей скринридеров.

<form novalidate>
  <p>
    <label for="mail">
      <span>Please enter an email address:</span>
      <input type="email" id="mail" name="mail" required minlength="8">
      <span class="error" aria-live="polite"></span>
    </label>
  </p>
  <button>Submit</button>
</form>